# 六子棋AI

### 简介：

这是中国海洋大学2024年秋季学期人工智能导论课程的07小组设计的一个六子棋AI程序，在课程中取得了**第一**的好成绩，仅在先手输1场



### 程序思路，运用的算法

* 基于路的思想估值
* alpha-beta剪枝
* 置换表 + zobrist哈希加速搜索速度
* 候选点范围限制在已有点周围两个内（再远的点对当前局面影响及其有限，故纳入考量得不偿失）

* ~~仅使用几个较优的开局~~(因老师限制，该优化最终被砍掉，使用该优化的程序获得了全胜)

### 优化思路

1. **威胁空间搜索**：利用威胁空间搜索持续产生2个以上威胁的方式寻找胜着
2. **置换表**：目前的置换表依然只存储在内存当中，后续可以尝试将其保存下来，在初始化程序时将其读入内存，这样应该可以进一步提高搜索效率
3. **开局选择**：选择较优开局，经测试的较优开局如下

### 较优开局

测试结果如下（对应开局表相应位置，开局表见附录）：
显著优势：18、19、22、3、20
微小优势：2，9

测试的定式：1，2，3，9，12，18，19，20，22，23

### 参考文献

[1]李学俊，王小龙，吴蕾，刘慧婷；六子棋中基于局部“路”扫描方式的博弈树生成算法[J]；智能系统学报；2015(02)

[2]岳金朋，冯速；博弈树搜索算法概述[J]；计算机系统应用；2009(09)



## 附录：开局表

```java
public static Move[] firstMoves = {
            new Move('J', 'K', 'K', 'I'),
            new Move('I', 'K', 'L', 'J'),
            new Move('I', 'K', 'L', 'K'),
            new Move('I', 'K', 'J', 'L'),
            new Move('J', 'K', 'K', 'J'),
            new Move('I', 'K', 'K', 'L'),
            new Move('J', 'L', 'L', 'J'),
            new Move('J', 'K', 'K', 'K'),
            new Move('J', 'L', 'L', 'L'),
            new Move('K', 'I', 'I', 'K'),
            new Move('J', 'K', 'L', 'J'),
            new Move('K', 'H', 'J', 'K'),
            new Move('L', 'H', 'J', 'L'),
            new Move('J', 'I', 'J', 'K'),
            new Move('I', 'L', 'K', 'L'),
            new Move('J', 'H', 'J', 'L'),
            new Move('J', 'L', 'L', 'K'),
            new Move('J', 'K', 'K', 'L'),
            new Move('L', 'I', 'J', 'K'),
            new Move('I', 'K', 'L', 'K'),
            new Move('J', 'L', 'K', 'L'),
            new Move('L', 'I', 'I', 'K'),
            new Move('I', 'K', 'I', 'L'),
            new Move('L', 'H', 'J', 'K'),
            new Move('J', 'K', 'L', 'K'),
            new Move('J', 'K', 'J', 'L')
    };
```

